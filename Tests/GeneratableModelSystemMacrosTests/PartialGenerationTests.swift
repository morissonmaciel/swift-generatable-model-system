//
//  PartialGenerationTests.swift
//  GeneratableModelSystemMacrosTests
//
//  Created by Morisson Marcel on 12/06/25.
//

import Foundation
import Testing
import GeneratableModelSystem
import GeneratableModelSystemMacros

@Test("TripPlan.PartiallyGenerated type is generated by macro")
func testTripPlanPartiallyGeneratedTypeExists() {
    // Verify that the PartiallyGenerated type is created
    let partialType = TripPlan.PartiallyGenerated.self
    #expect(partialType is PartiallyGeneratedProtocol.Type)
}

@Test("TripPlan.PartiallyGenerated has correct optional properties")
func testTripPlanPartiallyGeneratedProperties() {
    // Test that all @GeneratableGuide properties are optional in the partial type
    let partial = TripPlan.PartiallyGenerated()
    
    // These should all be nil by default (optional properties)
    #expect(partial.destination == nil)
    #expect(partial.activities == nil)
    #expect(partial.duration == nil)
}

@Test("TripPlan.PartiallyGenerated can be initialized with partial data")
func testTripPlanPartiallyGeneratedPartialInitialization() {
    // Test that we can create partial instances with some data
    var partial = TripPlan.PartiallyGenerated()
    partial.destination = .japan
    
    #expect(partial.destination == .japan)
    #expect(partial.activities == nil)
    #expect(partial.duration == nil)
}

@Test("TripPlan.PartiallyGenerated conforms to PartiallyGeneratedProtocol")
func testTripPlanPartiallyGeneratedProtocolConformance() {
    // Test protocol conformance and static properties
    #expect(TripPlan.PartiallyGenerated.parentType == TripPlan.self)
    #expect(TripPlan.PartiallyGenerated.description == "User trip plan")
    #expect(!TripPlan.PartiallyGenerated.scheme.isEmpty)
}

@Test("TripPlan.PartiallyGenerated scheme has all properties marked as optional")
func testTripPlanPartiallyGeneratedScheme() {
    let scheme = TripPlan.PartiallyGenerated.scheme
    
    // All properties should be marked as optional in the partial scheme
    #expect(scheme["destination"]?.isOptional == true)
    #expect(scheme["activities"]?.isOptional == true)
    #expect(scheme["duration"]?.isOptional == true)
    
    // But should maintain the same types and descriptions
    #expect(scheme["destination"]?.type == "string")
    #expect(scheme["destination"]?.description == "Country destination of user trip")
    #expect(scheme["destination"]?.validValues == ["Japan", "Brazil"])
    
    #expect(scheme["activities"]?.type == "array of strings")
    #expect(scheme["activities"]?.description == "List of activities planned for user trip")
    
    #expect(scheme["duration"]?.type == "integer")
    #expect(scheme["duration"]?.description == "Duration of user trip in days")
}

@Test("TripReservation.PartiallyGenerated respects custom JSON names")
func testTripReservationPartiallyGeneratedCustomNames() {
    let scheme = TripReservation.PartiallyGenerated.scheme
    
    // Should use custom names from @GeneratableGuide(name:) parameters
    #expect(scheme["trip_name"] != nil)
    #expect(scheme["start_date"] != nil)
    #expect(scheme["end_date"] != nil)
    #expect(scheme["passengers"] != nil)
    
    // Should not have the Swift property names when custom names are used
    #expect(scheme["tripName"] == nil)
    #expect(scheme["startDate"] == nil)
    #expect(scheme["endDate"] == nil)
}

@Test("TripPlan.PartiallyGenerated can be encoded/decoded from JSON")
func testTripPlanPartiallyGeneratedCodable() throws {
    // Create a partial instance
    var partial = TripPlan.PartiallyGenerated()
    partial.destination = .brazil
    partial.activities = ["Beach", "Samba"]
    // duration remains nil
    
    // Encode to JSON
    let encoder = JSONEncoder()
    let jsonData = try encoder.encode(partial)
    let jsonString = String(data: jsonData, encoding: .utf8)!
    
    // Should contain the set properties but not the nil ones
    #expect(jsonString.contains("Brazil"))
    #expect(jsonString.contains("Beach"))
    #expect(jsonString.contains("Samba"))
    
    // Decode back
    let decoder = JSONDecoder()
    let decoded = try decoder.decode(TripPlan.PartiallyGenerated.self, from: jsonData)
    
    #expect(decoded.destination == .brazil)
    #expect(decoded.activities == ["Beach", "Samba"])
    #expect(decoded.duration == nil)
}

@Test("String extractPartialJSON handles incomplete JSON")
func testStringExtractPartialJSON() {
    // Test with complete JSON (should work like extractJSON)
    let completeJSON = """
    Here's the response:
    ```json
    {"destination": "Japan", "duration": 7}
    ```
    """
    #expect(completeJSON.extractPartialJSON() == "{\"destination\": \"Japan\", \"duration\": 7}")
    
    // Test with incomplete JSON
    let incompleteJSON = """
    Here's the partial response:
    ```json
    {"destination": "Japan", "activiti
    """
    let partial = incompleteJSON.extractPartialJSON()
    #expect(partial != nil)
    #expect(partial!.contains("Japan"))
    
    // Test with no JSON
    let noJSON = "Just some text without JSON"
    #expect(noJSON.extractPartialJSON() == nil)
}

@Test("String extractPartialJSON handles valid partial objects")
func testStringExtractPartialJSONValidObjects() {
    // Test with a partial but valid JSON object
    let partialButValid = """
    {"destination": "Japan"}
    """
    #expect(partialButValid.extractPartialJSON() == "{\"destination\": \"Japan\"}")
    
    // Test with partial JSON that can be made valid
    let partialResponse = """
    Some text before
    {"destination": "Japan", "activities": ["Sushi"
    More text after
    """
    let extracted = partialResponse.extractPartialJSON()
    #expect(extracted != nil)
    #expect(extracted!.contains("Japan"))
}


@Test("LanguageModelSession respondPartially returns actual partial results")
func testLanguageModelSessionRespondPartiallyReturnsResults() async throws {
    // Setup streaming chunks with proper OpenAI streaming format (no usage field)
    MockURLProtocol.shouldStream = true
    MockURLProtocol.streamingChunks = [
        "data: {\"model\":\"test\",\"created\":1623456789,\"choices\":[{\"index\":0,\"text\":\"{\\\"destination\\\": \\\"Japan\\\"}\"}]}\n"
    ]
    
    defer {
        MockURLProtocol.shouldStream = false
        MockURLProtocol.streamingChunks = []
    }
    
    let provider = MockLanguageModelProvider(mockResponse: "unused")
    let mockURLSession = provider.makeURLSession()
    var session = LanguageModelSession("test-model")
    session.provider = provider
    session.urlSession = mockURLSession
    
    var partialResults: [TripPlan.PartiallyGenerated] = []
    
    // Actually consume the stream and collect results
    for try await partial in session.respondPartially(to: "Generate a trip plan") as AsyncThrowingStream<TripPlan.PartiallyGenerated?, Error> {
        if let partial = partial {
            partialResults.append(partial)
            break // Get at least one result
        }
    }
    
    #expect(!partialResults.isEmpty, "Should return actual partial results")
    #expect(partialResults.first?.destination == .japan, "Should parse destination correctly")
}

@Test("String extractPartialJSON with text fragments completes incomplete strings")
func testStringExtractPartialJSONWithTextFragments() {
    let scheme: [String: GuideDescriptor] = [
        "destination": GuideDescriptor(type: "string", description: "Country destination"),
        "duration": GuideDescriptor(type: "integer", description: "Duration in days")
    ]
    
    // Test incomplete string in destination (string type)
    let incompleteDestination = "{\"destination\": \"Jap"
    let completed = incompleteDestination.extractPartialJSON(allowsTextFragment: true, scheme: scheme)
    #expect(completed != nil)
    #expect(completed!.contains("\"Jap\""))
    #expect(completed!.contains("}"))
    
    // Test that it doesn't fragment non-string types
    let incompleteNumber = "{\"duration\": 7"
    let completedNumber = incompleteNumber.extractPartialJSON(allowsTextFragment: true, scheme: scheme)
    #expect(completedNumber != nil)
    #expect(completedNumber!.contains("7}"))
    
    // Test with text fragment disabled
    let withoutFragments = incompleteDestination.extractPartialJSON(allowsTextFragment: false, scheme: scheme)
    #expect(withoutFragments == nil) // Should not complete when fragments disabled
}

@Test("String extractPartialJSON text fragments work with multiple properties")
func testStringExtractPartialJSONMultipleProperties() {
    let scheme: [String: GuideDescriptor] = [
        "destination": GuideDescriptor(type: "string", description: "Country destination"),
        "activities": GuideDescriptor(type: "array of strings", description: "List of activities")
    ]
    
    // Test multiple properties with last one incomplete
    let multipleProperties = "{\"destination\": \"Japan\", \"activities\": [\"Sush"
    let completed = multipleProperties.extractPartialJSON(allowsTextFragment: true, scheme: scheme)
    #expect(completed != nil)
    #expect(completed!.contains("\"Japan\""))
    
    // For array elements, we currently only complete the structure, not text fragments inside arrays
    // This is by design as text fragment completion focuses on direct string properties
}

@Test("String extractPartialJSON validates string types before fragmenting")
func testStringExtractPartialJSONValidatesStringTypes() {
    let scheme: [String: GuideDescriptor] = [
        "destination": GuideDescriptor(type: "string", description: "Country destination"),
        "isActive": GuideDescriptor(type: "boolean", description: "Active status")
    ]
    
    // Test that boolean fields don't get text fragment completion
    let incompleteBool = "{\"isActive\": tr"
    let completed = incompleteBool.extractPartialJSON(allowsTextFragment: true, scheme: scheme)
    
    // For incomplete boolean values, the completion might fail since "tr" isn't valid JSON
    // This is expected behavior - we only complete string types
    if let result = completed {
        #expect(!result.contains("\"tr\"")) // Should not quote the boolean fragment
    } else {
        // It's also acceptable for this to fail to parse since "tr" is not a valid boolean
        #expect(completed == nil)
    }
}

@Test("LanguageModelSession respondPartially with allowsTextFragment parameter actually handles fragments")
func testLanguageModelSessionRespondPartiallyWithTextFragments() async throws {
    // Setup streaming chunk with proper OpenAI streaming format (no usage field)
    MockURLProtocol.shouldStream = true
    MockURLProtocol.streamingChunks = [
        "data: {\"model\":\"test\",\"created\":1623456789,\"choices\":[{\"index\":0,\"text\":\"{\\\"destination\\\": \\\"Japan\\\"}\"}]}\n"
    ]
    
    defer {
        MockURLProtocol.shouldStream = false
        MockURLProtocol.streamingChunks = []
    }
    
    let provider = MockLanguageModelProvider(mockResponse: "unused")
    let mockURLSession = provider.makeURLSession()
    var session = LanguageModelSession("test-model")
    session.provider = provider
    session.urlSession = mockURLSession
    
    var fragmentResults: [TripPlan.PartiallyGenerated] = []
    
    // Test with allowsTextFragment enabled
    for try await partial in session.respondPartially(to: "Generate a trip plan", allowsTextFragment: true) as AsyncThrowingStream<TripPlan.PartiallyGenerated?, Error> {
        if let partial = partial {
            fragmentResults.append(partial)
            break
        }
    }
    
    // Should be able to handle text fragments parameter and return results
    #expect(!fragmentResults.isEmpty, "Should handle text fragments parameter and return results")
    #expect(fragmentResults.first?.destination == .japan, "Should parse destination with text fragments enabled")
}